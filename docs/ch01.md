# 第一章：为什么要证明程序的正确性

经典的工程学科都有其规范化的数学技术，这些技术会被应用在任何产品被部署之前的设计过程中，使其安全性、某些方面的适用性等等符合我们的要求。同一个学科的工程师们对于审查设计方案时所应当遵循的“规则”，或多或少地都能够取得一致的意见。这些规则最后被高度严格地确定下来，因此，一个设计方案是否安全便不再是一个主观意见上的问题了。为什么在软件工程领域没有一个与之对应、约定俗成的标准，能够让程序员们确信他们所编写的系统是安全、可靠且正确的？这些理念，以及为此开发的工具，虽然尚未能够被广泛采用，但实际上已经经历了数十年的开发。本书将介绍这些工具中的一种，以及如何将其应用于程序证明中的各种任务。

由于本书还处于非常早期的草稿阶段，因此这里不再做更多的介绍，而是直接进入技术性的内容。在最终的版本里，毫无疑问这里应当有一些历史概述的内容作为背景介绍的一部分。同样的，也会有大量的学术性引用，无论是在本章还是在全书中。在这个早期版本中，作者向各位读者保证，我们即将学习的是一个非常有前景的技术。

然而，在我们的规划中有一个十分重要的原则，需要在此指出。我们将会学习各种不同的方法，用于对程序应有的行为进行形式化描述，并对程序确实执行了这些行为进行证明。在每一个步骤中，我们都会密切关注所有这些内容的 *共同基础*。首先，我们将使用Coq证明助手证明我们的所有定理，这是一个用于编写证明并对其进行机器检查的强大框架。Coq本身只包含一组相对较小的核心功能，它就像一门精心设计的编程语言，在这两者的基础上我们都构建出了日益复杂的抽象与程序库。我们可以将这些功能视作所有数学推理的核心。

我们还将采用另一个专门用于程序证明的方法。当我们面临证明一个新程序的某个新属性的挑战时，我们通常会考虑以下四个概括性的要素，这些要素几乎出现在本书所涉及的所有证明技术中。

* **编码** 每种编程语言都有其 *语法（syntax）* 和 *语义（semantics）*。语法定义了程序的外在，语义定义了程序的行为。虽然这些要素看上去相当直观，但一个经常出现的情况是，在以最严格的规范定义语法和语义时，我们需要做出一些十分微妙的选择，而这些看似微小的决定会对证明能否顺利进行产生很大的影响。
* **不变量** 几乎每一个关于程序的定理都是以 *转移系统（transition system）* 的形式描述的。一个转移系统包含了若干状态的集合，以及如何随着时间的推移从一个状态转移到另一个状态这一关系的定义。几乎所有的程序证明都是通过找到转移系统中的 *不变量（invariant）* 来实现的。简单来说，它是指从某个起始状态出发，对每个状态都能够成立的属性。不变量的概念非常像是对数学归纳法这一为人所熟知、为人所喜爱、并且在数学的发展过程中起到了重要作用的数学方法的直接解释。
* **抽象** 通常情况下，转移系统往往过于复杂，因此很难直接对其进行分析。因此，我们会将其 *抽象（abstract）* 为另一个在某些方面更易处理的转移系统，并证明新系统保留了原本的系统中所有与我们的分析有关的性质。
* **模块化** 类似地，如果一个转移系统过于复杂，我们通常会将其拆分成若干个彼此独立的 *模块（modules）*，再使用一些适合的组合运算符将这些模块重新组合成一个整体。抽象和模块化经常是一同出现的，我们首先将系统 *横向* 拆解（即，运用模块化方法），将其分成多个更容易处理的部分，然后 *纵向* 简化（即，运用抽象方法），并且让每个部分都保持其关键性质。我们还可以反复使用这几种策略，先将系统拆分、将其中一部分抽象成更简单的形式、再进一步对其进行拆分、诸如此类。

在本书中我们不会对这些基础技术进行完全形式化的定义。相反地，我们将会看到许多应用了这些方法的例子，每个例子都带有明显的旁注，标识出所使用到的技术。通过从这些示例中进行总结，有助于读者们对在什么场景下使用对应的技术以及哪些常见的设计模式适合应用在对应的场景里建立起感性的认识。

本书的核心主题通常可以根据传统的学科主题归入若干类别，如 *语义学（semantices）*、*编程语言理论（programming-languages theory）*、*形式化方法（formal methods）* 和 *验证（verification）*。这些学科对于相同的概念往往各自定义了一套术语。为了能够遵循统一的术语和记号，我们将在不同的学科习惯用语中进行挑选，形成一套特别的用语集合。在我们所将要研究的内容中，确实有大量共通的部分，我们不希望在学习的过程中为了需要在不同的术语之间反复进行翻译而分散了注意力。与此同时，掌握标准的符号的使用惯例是相当重要的，这些符号几乎全部由 $\LaTeX$ 实现。在本书中我们将始终使用这类符号。然而，我们还会采纳另一项并不常见的惯例：虽然我们在书中给出了定理及引理的表述，但我们几乎不会给出它们的证明。其原因是，本书的作者及当今的许多其它研究者都认为书面的证明已经失去了作用。取而代之的是，所有的证明都可以在随附的Coq代码中找到。

换言之，本书的每个章节都带有一个对应的Coq源代码文件，这些文件与本书的源代码一同发布。这些Coq源代码都加上了详细的注释，因此在许多时候甚至可供直接阅读而无需读者预习书中的对应章节。更重要的是，Coq代码不是仅用于 *阅读* 的，而是可以被 *运行* 的。我们建议交互地一步步运行这些代码，观察这些证明过程中的中间状态。当然，读者完全可以只阅读本书而先忽略Coq代码，以学习程序证明的背景知识内容；也可以只阅读Coq代码而先忽略书中的内容，以学习这些内容的具体实现。但是，同时阅读这二者的学习效果是最好的。